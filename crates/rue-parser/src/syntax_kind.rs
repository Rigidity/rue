use std::fmt;

use num_derive::{FromPrimitive, ToPrimitive};

#[derive(
    Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, ToPrimitive, FromPrimitive,
)]
pub enum SyntaxKind {
    #[default]
    Eof,
    Error,
    Ident,
    Int,
    Hex,
    String,
    OpenParen,
    CloseParen,
    OpenBracket,
    CloseBracket,
    OpenBrace,
    CloseBrace,
    Mod,
    Fun,
    Inline,
    Import,
    Export,
    Type,
    Struct,
    Enum,
    Let,
    Const,
    If,
    Else,
    Return,
    Raise,
    Assert,
    Assume,
    Nil,
    True,
    False,
    As,
    Is,
    Dot,
    Comma,
    Colon,
    PathSeparator,
    Semicolon,
    Arrow,
    FatArrow,
    Spread,
    Question,
    Plus,
    Minus,
    Star,
    Slash,
    Percent,
    Not,
    LessThan,
    GreaterThan,
    LessThanEquals,
    GreaterThanEquals,
    Equals,
    NotEquals,
    Assign,
    BitwiseAnd,
    BitwiseOr,
    BitwiseXor,
    BitwiseNot,
    LeftArithShift,
    RightArithShift,
    And,
    Or,
    Whitespace,
    LineComment,
    BlockComment,
    Root,
    ModuleItem,
    FunctionItem,
    FunctionParam,
    TypeAliasItem,
    StructItem,
    StructField,
    EnumItem,
    EnumVariant,
    EnumVariantFields,
    ConstItem,
    ImportItem,
    ImportPath,
    ImportGroup,
    LetStmt,
    IfStmt,
    ReturnStmt,
    RaiseStmt,
    AssertStmt,
    AssumeStmt,
    Block,
    PathExpr,
    InitializerExpr,
    InitializerField,
    LiteralExpr,
    ListExpr,
    ListItem,
    PairExpr,
    LambdaExpr,
    LambdaParam,
    PrefixExpr,
    BinaryExpr,
    GroupExpr,
    CastExpr,
    GuardExpr,
    IfExpr,
    FunctionCallExpr,
    FunctionCallArg,
    FieldAccessExpr,
    ExistsExpr,
    PathType,
    PairType,
    FunctionType,
    FunctionTypeParam,
    UnionType,
    GenericParams,
    GenericArgs,
    PathItem,
}

impl fmt::Display for SyntaxKind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                Self::Eof => "end of file",
                Self::Error => "error",
                Self::Ident => "identifier",
                Self::Int => "integer literal",
                Self::Hex => "hex literal",
                Self::String => "string",
                Self::OpenParen => "'('",
                Self::CloseParen => "')'",
                Self::OpenBracket => "'['",
                Self::CloseBracket => "']'",
                Self::OpenBrace => "'{'",
                Self::CloseBrace => "'}'",
                Self::Mod => "'mod'",
                Self::Fun => "'fun'",
                Self::Inline => "'inline'",
                Self::Import => "'import'",
                Self::Export => "'export'",
                Self::Type => "'type'",
                Self::Struct => "'struct'",
                Self::Enum => "'enum'",
                Self::Let => "'let'",
                Self::Const => "'const'",
                Self::If => "'if'",
                Self::Else => "'else'",
                Self::Return => "'return'",
                Self::Raise => "'raise'",
                Self::Assert => "'assert'",
                Self::Assume => "'assume'",
                Self::Nil => "'nil'",
                Self::True => "'true'",
                Self::False => "'false'",
                Self::As => "'as'",
                Self::Is => "'is'",
                Self::Dot => "'.'",
                Self::Comma => "','",
                Self::Colon => "':'",
                Self::PathSeparator => "'::'",
                Self::Semicolon => "';'",
                Self::Arrow => "'->'",
                Self::FatArrow => "'=>'",
                Self::Spread => "'...'",
                Self::Question => "'?'",
                Self::Plus => "'+'",
                Self::Minus => "'-'",
                Self::Star => "'*'",
                Self::Slash => "'/'",
                Self::Percent => "'%'",
                Self::Not => "'!'",
                Self::LessThan => "'<'",
                Self::GreaterThan => "'>'",
                Self::LessThanEquals => "'<='",
                Self::GreaterThanEquals => "'>='",
                Self::Equals => "'=='",
                Self::NotEquals => "'!='",
                Self::Assign => "'='",
                Self::BitwiseAnd => "'&'",
                Self::BitwiseOr => "'|'",
                Self::BitwiseXor => "'^'",
                Self::BitwiseNot => "'~'",
                Self::LeftArithShift => "'<<'",
                Self::RightArithShift => "'>>'",
                Self::And => "'&&'",
                Self::Or => "'||'",
                Self::Whitespace => "whitespace",
                Self::LineComment => "line comment",
                Self::BlockComment => "block comment",
                Self::Root => "root",
                Self::ModuleItem => "module item",
                Self::FunctionItem => "function item",
                Self::FunctionParam => "function param",
                Self::TypeAliasItem => "type alias item",
                Self::StructItem => "struct item",
                Self::StructField => "struct field",
                Self::EnumItem => "enum item",
                Self::EnumVariant => "enum variant",
                Self::EnumVariantFields => "enum variant fields",
                Self::ConstItem => "const item",
                Self::ImportItem => "import item",
                Self::ImportPath => "import path",
                Self::ImportGroup => "import group",
                Self::LetStmt => "let statement",
                Self::IfStmt => "if statement",
                Self::ReturnStmt => "return statement",
                Self::RaiseStmt => "raise statement",
                Self::AssertStmt => "assert statement",
                Self::AssumeStmt => "assume statement",
                Self::Block => "block",
                Self::PathExpr => "path expression",
                Self::InitializerExpr => "initializer expression",
                Self::InitializerField => "initializer field",
                Self::LiteralExpr => "literal expression",
                Self::ListExpr => "list expression",
                Self::ListItem => "list item",
                Self::PairExpr => "pair expression",
                Self::LambdaExpr => "lambda expression",
                Self::LambdaParam => "lambda param",
                Self::PrefixExpr => "prefix expression",
                Self::BinaryExpr => "binary expression",
                Self::GroupExpr => "group expression",
                Self::CastExpr => "cast expression",
                Self::GuardExpr => "guard expression",
                Self::IfExpr => "if expression",
                Self::FunctionCallExpr => "function call expression",
                Self::FunctionCallArg => "function call argument",
                Self::FieldAccessExpr => "field access expression",
                Self::ExistsExpr => "exists expression",
                Self::PathType => "path type",
                Self::PairType => "pair type",
                Self::FunctionType => "function type",
                Self::FunctionTypeParam => "function type parameter",
                Self::UnionType => "union type",
                Self::GenericParams => "generic parameters",
                Self::GenericArgs => "generic arguments",
                Self::PathItem => "path item",
            }
        )
    }
}
