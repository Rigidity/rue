enum Condition {
    CreateCoin = 51 {
        puzzle_hash: Bytes32,
        amount: Int,
        memos: Bytes[],
    },
    CreateCoinAnnouncement = 60 {
        message: Bytes,
    },
    AssertMyAmount = 73 {
        amount: Int,
    },
}

struct Payout {
    puzzle_hash: Bytes32,
    share: Int,
}

fun main(payouts: Payout[], my_amount: Int, total_shares: Int) -> Condition[] {
    let announcement = Condition::CreateCoinAnnouncement { message: nil };
    let assert_amount = Condition::AssertMyAmount { amount: my_amount };

    let conditions = calculate_amount_and_split(payouts, my_amount, total_shares, 0, my_amount);

    [announcement, assert_amount, ...conditions]
}

fun calculate_amount_and_split(
    payouts: Payout[],
    total_amount: Int,
    total_shares: Int,
    shares_sum: Int,
    remaining_amount: Int,
) -> Condition[] {
    if payouts is (Payout, Payout[]) {
        let amount = get_amount(payouts.first, total_amount, total_shares);
        return split_amount_and_create_coins(payouts, amount, total_amount, total_shares, shares_sum, remaining_amount);
    }
    assert total_shares == shares_sum;
    []
}

fun split_amount_and_create_coins(
    payouts: (Payout, Payout[]),
    this_amount: Int,
    total_amount: Int,
    total_shares: Int,
    shares_sum: Int,
    remaining_amount: Int,
) -> Condition[] {
    let payout = payouts.first;
    let create_coin = Condition::CreateCoin {
        puzzle_hash: payout.puzzle_hash,
        amount: if payout.share > 0 { this_amount } else { remaining_amount },
        memos: [payout.puzzle_hash],
    };
    let rest = calculate_amount_and_split(payouts.rest, total_amount, total_shares, shares_sum + payout.share, remaining_amount - this_amount);
    [create_coin, ...rest]
}

fun get_amount(payout: Payout, total_amount: Int, total_shares: Int) -> Int {
    (total_amount * payout.share) / total_shares
}
